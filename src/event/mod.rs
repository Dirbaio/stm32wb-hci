//! Bluetooth events and event deserialization.
//!
//! This module defines all of the HCI events that can be generated by the Bluetooth controller. In
//! addition to all of the event types, the core functionality of the module is [`parse_event`],
//! which converts a byte buffer into an HCI event.
//!
//! # Future possibilities
//!
//! There are some 76 events defined by the Bluetooth specification (Version 5.0), in addition to
//! vendor events (which would be defined by vendor support crates). That many structs may make this
//! module unwieldly, so this may need to be split up into submodules for different events, similar
//! to the way CommandComplete is split into its own submodule.

pub mod command;

use byteorder::{ByteOrder, LittleEndian};
use core::convert::TryInto;
use core::marker::Sized;

/// Defines a newtype to indicate that the buffer is supposed to contain an HCI event.
pub struct Packet<'a>(pub &'a [u8]);

/// Errors that may occur when deserializing an event. Must be specialized by the vendor crate to
/// allow for vendor-specific event errors.
#[derive(Copy, Clone, Debug)]
pub enum Error<V> {
    /// The event type byte was unknown. The byte is provided.
    UnknownEvent(u8),

    /// The buffer provided that is supposed to contain an event does not have the correct
    /// length. Field 0 is the provided length, field 1 is the expected length.
    BadLength(usize, usize),

    /// Specific to the CommandStatus event. The status code was unknown. The unknown value is
    /// provided.
    UnknownStatus(u8),

    /// A vendor-specific error was detected when deserializing a vendor-specific event.
    Vendor(V),
}

/// The Command Status event. This event is generated to indicate that an asynchronous operation has
/// begun (or could not begin).
///
/// Defined in Vol 2, Part E, Section 7.7.15 of the spec.
#[derive(Copy, Clone, Debug)]
pub struct CommandStatus {
    /// Status of the command that has started.
    pub status: ::Status,

    /// Number of HCI Command packets that can be sent to the controller from the host.
    pub num_hci_command_packets: u8,

    /// Opcode of the command that generated this CommandStatus event. The controller can generate a
    /// spontaneous CommandStatus with opcode 0 if the number of allowed HCI commands has changed.
    pub op_code: ::opcode::OpCode,
}

impl CommandStatus {
    const LENGTH: usize = 4;

    fn new<VE>(buffer: &[u8]) -> Result<CommandStatus, Error<VE>> {
        if buffer.len() != Self::LENGTH {
            return Err(Error::BadLength(buffer.len(), Self::LENGTH));
        }

        Ok(CommandStatus {
            status: buffer[0].try_into().map_err(|e| {
                let ::StatusFromU8Error::BadValue(v) = e;
                Error::UnknownStatus(v)
            })?,
            num_hci_command_packets: buffer[1],
            op_code: ::opcode::OpCode(LittleEndian::read_u16(&buffer[2..])),
        })
    }
}

/// Trait for vendor-specific events.
pub trait VendorEvent {
    /// Enumeration of vendor-specific errors that may occur when deserializing events. Generally,
    /// this means some values in the buffer are out of range for the event.
    type Error;

    /// Creates a new vendor-specific event from the contents of buffer. The buffer contains only
    /// the payload of the event, which does not include the BLE event type (which must be 0xFF) or
    /// the parameter length (which is provided by `buffer.len()`).
    ///
    /// # Errors
    ///
    /// - Shall return one of the appropriate error types (potentially including vendor-specific
    ///   errors) if the buffer does not describe a valid event.
    fn new(buffer: &[u8]) -> Result<Self, Error<Self::Error>>
    where
        Self: Sized;
}

/// Potential events that can be generated by the controller.
///
/// See Vol 2, Part E, Section 7.7 for a description of each event.
#[derive(Clone, Debug)]
pub enum Event<Vendor> {
    /// Vol 2, Part E, Section 7.7.14
    CommandComplete(command::CommandComplete),

    /// Vol 2, Part E, Section 7.7.15
    CommandStatus(CommandStatus),

    /// Vendor-specific events (opcode 0xFF)
    Vendor(Vendor),
}

mod etype {
    pub const COMMAND_COMPLETE: u8 = 0x0E;
    pub const COMMAND_STATUS: u8 = 0x0F;
    pub const VENDOR: u8 = 0xFF;
}

const PACKET_HEADER_LENGTH: usize = 2;
const EVENT_TYPE_BYTE: usize = 0;
const PARAM_LEN_BYTE: usize = 1;

impl<'a> Packet<'a> {
    fn full_length(&self) -> usize {
        PACKET_HEADER_LENGTH + self.0[PARAM_LEN_BYTE] as usize
    }
}

/// Deserializes an event from the given packet. The packet should contain all of the data needed
/// to deserialize the event.
///
/// # Errors
///
/// - Returns an UnknownEvent error if the first byte of the header is not a recognized event
///   type. This includes events that may be valid BLE events, but are not yet be implemented by
///   this crate.
///
/// - Returns a BadLength error if the length of the packet is not sufficient to either (1) contain
///   a packet header, or (2) contain the packet data as defined by the header.
///
/// - Returns other errors if the particular event cannot be correctly deserialized from the
///   packet. This includes vendor-specific errors for vendor events.
pub fn parse_event<VEvent, VError>(packet: Packet) -> Result<Event<VEvent>, Error<VError>>
where
    VEvent: VendorEvent<Error = VError>,
{
    if packet.0.len() < PACKET_HEADER_LENGTH || packet.0.len() < packet.full_length() {
        return Err(Error::BadLength(packet.0.len(), packet.full_length()));
    }

    let event_type = packet.0[EVENT_TYPE_BYTE];
    let payload = &packet.0[PACKET_HEADER_LENGTH..packet.full_length()];
    match event_type {
        etype::COMMAND_COMPLETE => Ok(Event::CommandComplete(command::CommandComplete::new(
            payload,
        )?)),
        etype::COMMAND_STATUS => Ok(Event::CommandStatus(CommandStatus::new(payload)?)),
        etype::VENDOR => Ok(Event::Vendor(VEvent::new(payload)?)),
        _ => Err(Error::UnknownEvent(event_type)),
    }
}
